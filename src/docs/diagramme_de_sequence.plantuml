@startuml
title Diagramme de séquence — Récupération & scoring des actualités

actor Client
boundary "PreferencesApi" as API
control "NewsService" as Service
control "NewsCollectionFactory" as Factory
control "LLMScorer" as Scorer
control "NewsSorter" as Sorter
entity "RssFetcher(s)" as Fetchers

== Appel ==
Client -> API : GET /news?themes=...
activate API

API -> Service : getNewsForThemes(themes)
activate Service

' --- Récupération en un seul batch ---
Service -> Factory : fromSources(fetchers, themes)
activate Factory
Factory -> Fetchers : fetchAll()  ' appel conceptuel : agrège toutes les sources
Fetchers --> Factory : List<News> (toutes les news)
Factory --> Service : NewsCollection
deactivate Factory

' --- Scoring & matching ---
' Le LLM peut être appelé en batch (une fois) pour toutes les news,
' mais le "matching" utilisateur (calculateMatchScore) s'applique par news.
Service -> Scorer : score(collection.items, themes)\n(batched)
activate Scorer
Scorer --> Service : Map<NewsId, Map<Category,Score>>
deactivate Scorer

loop pour chaque News de la collection
  Service -> Service : calculateMatchScore(news, userPreferences)
end

Service -> Sorter : sort(collection)
activate Sorter
Sorter --> Service : NewsCollection (triée)
deactivate Sorter

Service --> API : NewsCollection
deactivate Service

API --> Client : 200 OK\nList<NewsDTO>
deactivate API

== Erreur (alt) ==
alt échec partiel d'une source RSS
  Factory --> Service : collection partielle
else échec critique (LLM ou parsing)
  Service --> API : ApiException
  API --> Client : 5xx ErrorResponse
end

@enduml
